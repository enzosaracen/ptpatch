// globals/arbitrary C code accessible by all hooks go at the top
// of the file before a delimiting line containing "%%".
// be careful of clobbering predefined convenience variables/functions,
// which are viewable in stub.gen.c

int break_cnt = 0;
long saved_rdx = 0;

// following the "%%", a series of hooks are defined in the format:
// <@ `breakpoint`
//     // C code
// @>

// `breakpoint` is usually interpreted as an arbitrary
// C expression that evaluates to an address in the binary to break on,
// unless `breakpoint` matches the following special cases:
//      - starts with `pre-syscall` or `post-syscall`,
//        followed by a syscall name or number

// the predefined variable `base` contains the exe base address for
// PIE executables, which will be necessary to specify valid breakpoints

%%

<@ base+0x1151
    // predefined variables/functions available in hooks:

    // - `regs` defines current register state,
    //      - of type `struct user_regs_struct`
    //      - any modifications will be committed
    //        after the hook finishes

	// - `pid` pid of current tracee

    // - `int mem_write(char *addr, char *buf, int n)`
    //      - writes `n` bytes from `buf` to `addr` in the
    //        tracee's memory

    // - `int mem_read(char *addr, char *buf, int n)`
    //      - reads `n` bytes from `addr` into `buf` from
    //        the tracee's memory
    
    break_cnt++;
    printf("hit base+0x1151 %d times\n", break_cnt);
@>

<@ pre-syscall write
    // pre-syscall hooks will be run before the syscall is entered
    
    mem_write(regs.rsi, "intercepted!\n", 13);
    saved_rdx = regs.rdx;
    regs.rdx = 13;
@>

<@ post-syscall write
    // post-syscall hooks will be run after the syscall is entered

    // we do this to appease libc's write, thinking it wrote
    // as many bytes as it originally requested
    regs.rax = saved_rdx;
@>
